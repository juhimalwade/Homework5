if (length(object@value) == length(object@pos)) {
# Check that all positions are positive integers
if (any(substr(object@pos, 1, 1) > 0)) {
#Check that there no two values have the same position
if (!any(duplicated(object@pos))) {
#Check that length of vector is less than or equal to the length of the values
if (substr(object@length, 1, 1) > 0 && length(object@value) <= substr(object@length, 1, 1)) {
TRUE
}
}
}
}
FALSE
})
## HW5_testscript.R
library(testthat)
if(!file.exists("HW5_Class.R")) {
stop("cannot find file 'HW5_Class.R'")
}
setwd("~/Documents/SDS 375/Homework5")
setwd("~/Documents/SDS 375/Homework5")
## HW5_testscript.R
library(testthat)
if(!file.exists("HW5_Class.R")) {
stop("cannot find file 'HW5_Class.R'")
}
source("HW5_Class.R")
test_that("check validity method exists", {
expect_false({
validity_method <- getValidity(getClassDef("sparse_numeric"))
is.null(validity_method)
})
})
test_that("check validity method", {
expect_true({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
validObject(x)
})
})
library(testthat)
if(!file.exists("HW5_Class.R")) {
stop("cannot find file 'HW5_Class.R'")
}
source("HW5_Class.R")
test_that("check validity method exists", {
expect_false({
validity_method <- getValidity(getClassDef("sparse_numeric"))
is.null(validity_method)
})
})
test_that("check validity method", {
expect_true({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
validObject(x)
})
})
test_that("check validity method 2", {
expect_error({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
x@length <- 2L
validObject(x)
})
})
## HW5 Class/Methods
setClass(
Class = "sparse_numeric",
slots = c(
value = "numeric",
pos = "integer",
length = "integer"
)
)
#Validity Method
setValidity("sparse_numeric", function(object) {
#Check that values and positions have one-to-one relationship
if (length(object@value) == length(object@pos)) {
# Check that all positions are positive integers
if (any(object@pos > 0)) {
#Check that there no two values have the same position
if (!any(duplicated(object@pos))) {
#Check that length of vector is less than or equal to the length of the values
if (object@length > 0 && length(object@value) <= object@length) {
TRUE
}
}
}
}
FALSE
})
test_that("check validity method", {
expect_true({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
validObject(x)
})
})
setClass(
Class = "sparse_numeric",
slots = c(
value = "numeric",
pos = "integer",
length = "integer"
)
)
setValidity("sparse_numeric", function(object) {
# Check that values and positions have one-to-one relationship
if (length(object@value) != length(object@pos)) {
return("Values and positions must have the same length.")
}
# Check that all positions are positive integers
if (any(object@pos <= 0)) {
return("All positions must be positive integers.")
}
# Check for duplicate positions
if (any(duplicated(object@pos))) {
return("Positions must be unique.")
}
# Check that length is positive and large enough
if (object@length <= 0 || length(object@value) > object@length) {
return("Length must be positive and >= number of values.")
}
TRUE
})
test_that("check validity method", {
expect_true({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
validObject(x)
})
})
test_that("check validity method exists", {
expect_false({
validity_method <- getValidity(getClassDef("sparse_numeric"))
is.null(validity_method)
})
})
test_that("check validity method 2", {
expect_error({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
x@length <- 2L
validObject(x)
})
})
setAs("numeric", "sparse_numeric", function(from) {
index_nonzero = which(from != 0)
new("sparse_numeric",
value = from[index_nonzero],
pos = as.integer(index_nonzero),
length = as.integer(length(from)))
})
setAs("sparse_numeric", "numeric", function(from) {
x = numeric(from@length)
if (length(from@pos) > 0)
x[from@pos] = from@value
x
})
test_that("check coercion return class", {
expect_s4_class({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
}, "sparse_numeric")
})
setMethod("sparse_add", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
setGeneric("sparse_add", function(x, y, ...) standardGeneric("sparse_add"))
setGeneric("sparse_sub", function(x, y, ...) standardGeneric("sparse_sub"))
setGeneric("sparse_mult", function(x, y, ...) standardGeneric("sparse_mult"))
setGeneric("sparse_crossprod", function(x, y, ...) standardGeneric("sparse_crossprod"))
setMethod("sparse_add", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
test_that("check for + method", {
expect_no_error({
getMethod("+", c("sparse_numeric", "sparse_numeric"))
})
})
setGeneric("sparse_add", function(x, y, ...) standardGeneric("sparse_add"))
setGeneric("sparse_sub", function(x, y, ...) standardGeneric("sparse_sub"))
setGeneric("sparse_mult", function(x, y, ...) standardGeneric("sparse_mult"))
setGeneric("sparse_crossprod", function(x, y, ...) standardGeneric("sparse_crossprod"))
setMethod("+", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
#Generic
setGeneric("+", function(x, y, ...) standardGeneric("sparse_add"))
setMethod("+", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
#Generic
setGeneric("sparse_add", function(x, y, ...) standardGeneric("+"))
setMethod("+", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
setGeneric("sparse_add", function(x, y, ...) standardGeneric("sparse_add"))
setGeneric("sparse_sub", function(x, y, ...) standardGeneric("sparse_sub"))
setGeneric("sparse_mult", function(x, y, ...) standardGeneric("sparse_mult"))
setGeneric("sparse_crossprod", function(x, y, ...) standardGeneric("sparse_crossprod"))
setMethod("sparse_add", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
if (x@length != y@length)
stop("Vectors are not the same length")
all_pos <- sort(unique(c(x@pos, y@pos)))
# initialize values
xv <- rep(0, length(all_pos))
yv <- rep(0, length(all_pos))
if (length(x@pos) > 0)
xv[match(x@pos, all_pos)] <- x@value
if (length(y@pos) > 0)
yv[match(y@pos, all_pos)] <- y@value
res <- xv + yv
keep <- which(res != 0)
new("sparse_numeric",
value = res[keep],
pos = as.integer(all_pos[keep]),
length = x@length)
})
setMethod("+", c("sparse_numeric", "sparse_numeric"),
function(e1, e2) sparse_add(e1, e2))
test_that("check for + method", {
expect_no_error({
getMethod("+", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("sparse_add", {
result <- as(c(1, 1, 0, 1, 6), "sparse_numeric")
expect_equal({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 0, 0, 4), "sparse_numeric")
sparse_add(x, y)
}, result)
})
test_that("sparse add dense", {
result <- as(c(2, 4, 6, 10, 12), "sparse_numeric")
expect_equal({
x <- as(c(1, 3, 4, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 2, 9, 10), "sparse_numeric")
sparse_add(x, y)
}, result)
})
test_that("all zero wrong length", {
expect_error({
x <- as(rep(0, 10), "sparse_numeric")
y <- as(rep(0, 9), "sparse_numeric")
sparse_add(x, y)
})
})
test_that("check returned class for add", {
expect_s4_class({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 0, 0, 4), "sparse_numeric")
sparse_add(x, y)
}, "sparse_numeric")
})
test_that("sparse add formals", {
expect_true(length(formals(sparse_add)) >= 2L)
})
test_that("sparse add generic", expect_true(isGeneric("sparse_add")))
setMethod("sparse_sub",
signature(x = "sparse_numeric", y = "sparse_numeric"),
function(x, y) {
if (x@length != y@length)
stop("Both sparse vectors must be the same length.")
# combine all positions and ensure they are unique]
pos_all = unique(c(x@pos, y@pos)) #vector of all positions with non-zero values
pos_all = pos_all[order(pos_all)] #sort them
# result vector
combined_vals <- numeric(length(pos_all))
# add contributions from x and y
if (length(x@value))
combined_vals[match(x@pos, pos_all)] <- combined_vals[match(x@pos, pos_all)] + x@value
if (length(y@value))
combined_vals[match(y@pos, pos_all)] <- combined_vals[match(y@pos, pos_all)] - y@value
# remove zeroes
valid_idx = combined_vals != 0
# return new sparse numeric object
new("sparse_numeric",
value = combined_vals[valid_idx],
pos = as.integer(pos_all[valid_idx]),
length = x@length)
})
setMethod("-", c("sparse_numeric", "sparse_numeric"),
function(e1, e2) sparse_add(e1, e2))
test_that("check for - method", {
expect_no_error({
getMethod("-", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("sparse sub generic", expect_true(isGeneric("sparse_sub")))
test_that("sparse sub formals", {
expect_true(length(formals(sparse_sub)) >= 2L)
})
setMethod("show", "sparse_numeric", function(object) {
cat("Sparse numeric vector of length", object@length, "\n")
if (length(object@pos) == 0) {
cat("all elements are zero","\n")
} else {
cat("Positions that are not zero:", object@pos, "\n")
cat("Values at those positions:", object@value, "\n")
}
})
setMethod("plot", c("sparse_numeric", "sparse_numeric"),
function(x, y, ...) {
plot(x@pos, x@value, col = "blue",
xlab = "index", ylab = "value",
main = "non-zero elements of sparse vectors")
points(y@pos, y@value, col = "red")
legend("topright", legend = c("x", "y"),
col = c("blue", "red"))
})
## HW5_testscript.R
library(testthat)
if(!file.exists("HW5_Class.R")) {
stop("cannot find file 'HW5_Class.R'")
}
source("HW5_Class.R")
test_that("check validity method exists", {
expect_false({
validity_method <- getValidity(getClassDef("sparse_numeric"))
is.null(validity_method)
})
})
test_that("check validity method", {
expect_true({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
validObject(x)
})
})
test_that("check validity method 2", {
expect_error({
x <- new("sparse_numeric",
value = c(1, 2, 3, 1),
pos = c(1L, 2L, 3L, 5L),
length = 5L)
x@length <- 2L
validObject(x)
})
})
test_that("check coercion return class", {
expect_s4_class({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
}, "sparse_numeric")
})
test_that("check for show method", {
expect_no_error({
getMethod("show", "sparse_numeric")
})
})
test_that("check for plot method", {
expect_no_error({
getMethod("plot", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("check for + method", {
expect_no_error({
getMethod("+", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("check for - method", {
expect_no_error({
getMethod("-", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("check for * method", {
expect_no_error({
getMethod("*", c("sparse_numeric", "sparse_numeric"))
})
})
test_that("sparse add generic", expect_true(isGeneric("sparse_add")))
test_that("sparse mult generic", expect_true(isGeneric("sparse_mult")))
test_that("sparse sub generic", expect_true(isGeneric("sparse_sub")))
test_that("sparse crossprod generic", expect_true(isGeneric("sparse_crossprod")))
test_that("sparse add formals", {
expect_true(length(formals(sparse_add)) >= 2L)
})
test_that("sparse mult formals", {
expect_true(length(formals(sparse_mult)) >= 2L)
})
test_that("sparse sub formals", {
expect_true(length(formals(sparse_sub)) >= 2L)
})
test_that("sparse crossprod formals", {
expect_true(length(formals(sparse_crossprod)) >= 2L)
})
test_that("check returned class for add", {
expect_s4_class({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 0, 0, 4), "sparse_numeric")
sparse_add(x, y)
}, "sparse_numeric")
})
test_that("sparse_add", {
result <- as(c(1, 1, 0, 1, 6), "sparse_numeric")
expect_equal({
x <- as(c(0, 0, 0, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 0, 0, 4), "sparse_numeric")
sparse_add(x, y)
}, result)
})
test_that("sparse add dense", {
result <- as(c(2, 4, 6, 10, 12), "sparse_numeric")
expect_equal({
x <- as(c(1, 3, 4, 1, 2), "sparse_numeric")
y <- as(c(1, 1, 2, 9, 10), "sparse_numeric")
sparse_add(x, y)
}, result)
})
test_that("all zero wrong length", {
expect_error({
x <- as(rep(0, 10), "sparse_numeric")
y <- as(rep(0, 9), "sparse_numeric")
sparse_add(x, y)
})
})
